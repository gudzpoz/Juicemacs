plugins {
    id 'java'
    id 'net.ltgt.errorprone'
}

repositories {
    mavenCentral()
}

boolean isGraalVM() {
    return file("${System.getProperty("java.home")}/lib/graalvm").exists()
}
boolean runCoverage() {
    return project.hasProperty('coverage')
}
List<String> getGraalVMArgs() {
    if (runCoverage()) {
        // JaCoCo transforms the bytecode, which severely impacts how
        // Graal/Truffle JIT compile the program.
        // (For example, it introduces concurrency constructs to pass
        // signals for code coverage, which Graal/Truffle will try to
        // inline-&-compile and will eventually bail out because it is
        // just too complex.)
        // We only enable coverage when -Pcoverage is passed.
        project.logger.lifecycle('Enabling jacoco test coverage')
        rootProject.subprojects {
            apply plugin: 'jacoco'
            jacocoTestReport {
                reports {
                    xml.required = true
                    html.required = true
                }
            }
        }
        return ['-Dpolyglot.engine.Compilation=false']
    }
    boolean isGraalVM = isGraalVM()
    List<String> graalArgs = []
    String truffleVersion = libs.graalvm.truffle.api.get().version
    if (!isGraalVM) {
        var classpath = configurations.create('compilerClasspath') {
            canBeResolved = true
        }
        dependencies {
            compilerClasspath "org.graalvm.compiler:compiler:${truffleVersion}"
        }
        var jars = classpath.filter { it.name.endsWith(".jar") }  // Filter out POMs
        graalArgs += [
                '-XX:+UnlockExperimentalVMOptions',
                '-XX:+EnableJVMCI',
                "--upgrade-module-path=${jars.asPath}",
        ]
    }
    return graalArgs
}
int preferredJvmVersion() {
    if (!isGraalVM()) {
        return 25
    }
    String version = System.getProperty("java.version")
    String major = version.split("\\.")[0]
    return Math.max(Integer.parseInt(major), 25)
}

ext {
    graalArgs = getGraalVMArgs()
}

dependencies {
    errorprone libs.errorprone.core
    errorprone libs.errorprone.nullaway

    implementation libs.jspecify

    testImplementation libs.junit.jupiter
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(preferredJvmVersion())
    }
}

tasks.withType(JavaCompile).configureEach {
    options.errorprone {
        enabled = project.hasProperty('errorprone')
        disableWarningsInGeneratedCode = true
        option('NullAway:AnnotatedPackages', 'party.iroiro')

        // In contract to common Java practices, we use specialized types
        // as much as possible: ArrayList over List, HashMap over Map, etc.
        // This is to cater for Truffle's handling of polymorphism.
        disable('NonApiType')
        // We use this quite a lot, because Truffle @CompilationFinal only
        // recognizes arrays.
        disable('ArrayRecordComponent', 'MutablePublicArray')
        // We use a lot of reference equality comparisons, for symbols, for example.
        disable('ReferenceEquality')
        // If you are suggesting "using the value of the @return block as a summary fragment",
        // then the rule is wrong.
        disable('MissingSummary')
        // The current codebase is filled with function templates throwing
        // UnsupportedOperationExceptions.
        // TODO: remove this line after we finish the implementation
        disable('DoNotCallSuggester')
    }
}

tasks.named('test') {
    // Use JUnit Platform for unit tests.
    useJUnitPlatform()
    if (runCoverage()) {
        jvmArgs += ['-Dcoverage=true']
    }
}
