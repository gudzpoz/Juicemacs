#!/bin/python

import re
import sys


BC_DEFINE_REGEX = re.compile(
    r'DEFINE\s*\(\s*([^,]+?),\s*(\d+?)\s*\)'
)

if len(sys.argv) == 1:
    print('Usage: python extract-emacs-bytecode.py <path_to_bytecode.c> <constants|switch>')


bytecode_c = sys.argv[1]
option = sys.argv[2]

with open(bytecode_c) as f:
    content = f.read()
    bytecodes = BC_DEFINE_REGEX.findall(content)
    max_name_len = max(len(name) for name, _ in bytecodes)

if option == 'constants':
    print('''/**
 * Generated by {@code extract-emacs-bytecode.py} from {@code src/bytecode.c}
 */
public abstract class ByteCode {
    private ByteCode() {}
''')
    for name, code_oct in bytecodes:
        java_name = name[1:].upper()
        code = int(code_oct, 8)
        print(
            f'    public final static byte {java_name}'
            f'{" " * (max_name_len - len(java_name))} = '
            f'{"(byte) " if code >= 128 else ""}{code_oct};'
        )
    print('}')
elif option == 'switch':
    for name, code_oct in bytecodes:
        print(
            f'case {name[1:].upper()}:'
            f'{" " * (max_name_len - len(name))} // {code_oct}'
        )
