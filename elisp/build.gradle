/*
 * This project uses @Incubating APIs which are subject to change.
 */

plugins {
    id 'buildlogic.java-library-conventions'
    id 'me.champeau.jmh' version '0.7.2'
}

ext {
    truffleVersion = '24.1.1'
}

dependencies {
    pmd project(':commons:pmd-no-int')
    pmd 'net.sourceforge.pmd:pmd-ant:7.6.0'
    pmd 'net.sourceforge.pmd:pmd-java:7.6.0'

    implementation 'org.apache.commons:commons-text:1.12.0'
    implementation 'org.eclipse.jdt:org.eclipse.jdt.annotation:2.3.0'
    implementation 'org.eclipse.collections:eclipse-collections-api:11.1.0'
    implementation 'org.eclipse.collections:eclipse-collections:11.1.0'
    implementation 'com.lodborg:interval-tree:1.0.0'

    api "org.graalvm.truffle:truffle-api:${truffleVersion}"
    annotationProcessor "org.graalvm.truffle:truffle-dsl-processor:${truffleVersion}"
    runtimeOnly "org.graalvm.truffle:truffle-runtime:${truffleVersion}"

    testImplementation 'org.openjdk.jmh:jmh-core:1.37'
    testImplementation 'org.openjdk.jmh:jmh-generator-annprocess:1.37'
    testRuntimeOnly "org.graalvm.tools:profiler-tool:${truffleVersion}"
}

pmd {
    toolVersion = '7.6.0'
    incrementalAnalysis = true
    ruleSetFiles = files(
            'scripts/pmd-truffle-practices.xml',
            'scripts/pmd-elisp-cautions.xml',
            'scripts/pmd-linguistics.xml',
    )
    ruleSets = []
}

test {
    jvmArgs [
            '-Djdk.graal.Dump=:0',
            '-Dpolyglot.engine.TraceCompilation=true',
            '-Dpolyglot.engine.CompilationFailureAction=Silent',
    ]
}

// The following list several tasks that are used to generate Java sources from Emacs sources.

// A list, used later to enforce sequential evaluation
var ArrayList<String> extractEmacsTasks = []

// Built-in function template generation from Emacs sources
var ArrayList<List<String>> templateTasks = [
        ['Alloc', 'alloc.c'],
        ['Buffer', 'buffer.c'],
        ['CallInt', 'callint.c'],
        ['CaseFiddle', 'casefiddle.c'],
        ['CaseTab', 'casetab.c'],
        ['Character', 'character.c'],
        ['CharSet', 'charset.c'],
        ['CharTab', 'chartab.c'],
        ['Cmds', 'cmds.c'],
        ['Coding', 'coding.c'],
        ['Comp', 'comp.c'],
        ['Data', 'data.c'],
        ['EditFns', 'editfns.c'],
        ['Emacs', 'emacs.c'],
        ['Eval', 'eval.c'],
        ['FileIO', 'fileio.c'],
        ['Fns', 'fns.c'],
        ['Frame', 'frame.c'],
        ['Keyboard', 'keyboard.c'],
        ['Keymap', 'keymap.c'],
        ['LRead', 'lread.c'],
        ['Print', 'print.c'],
        ['Process', 'process.c'],
        ['Search', 'search.c'],
        ['Syntax', 'syntax.c'],
        ['TextProp', 'textprop.c'],
        ['TimeFns', 'timefns.c'],
        ['Window', 'window.c'],
        ['XDisp', 'xdisp.c'],
        ['XFaces', 'xfaces.c'],
]
var base = "src/main/java/party/iroiro/juicemacs/elisp"
var context = file("${base}/runtime/ELispContext.java")
var initExtractionScript = file("scripts/extract_emacs_init.py")
var utilsScript = file("scripts/extract_emacs_utils.py")
templateTasks.each {
    var templateScript = file("scripts/extract_emacs_src.py")
    var input = file("emacs/src/${it[1]}")
    var clazz = "BuiltIn${it[0]}"
    var target = file("${base}/forms/${clazz}.java")
    var buffer = file("${base}/runtime/ELispBuffer.java")
    var globals = file("${base}/runtime/ELispGlobals.java")
    var templateTaskName = "emacsGen${it[0]}"
    tasks.register(templateTaskName) {
        description = "${input}"
        inputs.files input, templateScript, utilsScript, initExtractionScript
        outputs.files target, context, globals
        doLast {
           exec {
                commandLine 'python', templateScript, input,
                        '-j', target, '-c', context, '-g', globals, '-b', buffer
            }
        }
    }
    extractEmacsTasks.add(templateTaskName)
}

// Force sequential evaluation
(0..<extractEmacsTasks.size() - 1).each { i ->
    var firstTaskName = extractEmacsTasks[i]
    var secondTaskName = extractEmacsTasks[i + 1]
    tasks.named(secondTaskName) {
        mustRunAfter tasks.named(firstTaskName)
    }
}

// One huge task to generate all sources
tasks.register("emacsGen") {
    description = 'Generate symbol/function definitions from Emacs source'
    dependsOn extractEmacsTasks.collect { tasks.named(it) }
}
