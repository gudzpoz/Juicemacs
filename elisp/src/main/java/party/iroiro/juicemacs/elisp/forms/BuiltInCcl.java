package party.iroiro.juicemacs.elisp.forms;

import com.oracle.truffle.api.dsl.GenerateNodeFactory;
import com.oracle.truffle.api.dsl.NodeFactory;
import com.oracle.truffle.api.dsl.Specialization;
import com.oracle.truffle.api.nodes.Node;
import party.iroiro.juicemacs.elisp.runtime.ELispContext;
import party.iroiro.juicemacs.elisp.runtime.objects.ELispSymbol;
import party.iroiro.juicemacs.elisp.runtime.objects.ELispVector;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

public class BuiltInCcl extends ELispBuiltIns {
    @Override
    protected List<? extends NodeFactory<? extends ELispBuiltInBaseNode>> getNodeFactories() {
        return BuiltInCclFactory.getFactories();
    }

    private final HashMap<ELispSymbol, Long> cclProgramIndices = new HashMap<>();
    private final ArrayList<CclProgram> cclPrograms = new ArrayList<>();

    private record CclProgram(ELispVector code) {
    }

    private static BuiltInCcl getThis(Node node) {
        return ELispContext.get(node).globals().builtInCcl;
    }

    /**
     * <pre>
     * Return t if OBJECT is a CCL program name or a compiled CCL program code.
     * See the documentation of `define-ccl-program' for the detail of CCL program.
     * </pre>
     */
    @ELispBuiltIn(name = "ccl-program-p", minArgs = 1, maxArgs = 1)
    @GenerateNodeFactory
    public abstract static class FCclProgramP extends ELispBuiltInBaseNode {
        @Specialization
        public static Void cclProgramP(Object object) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * <pre>
     * Execute CCL-PROGRAM with registers initialized by REGISTERS.
     *
     * CCL-PROGRAM is a CCL program name (symbol)
     * or compiled code generated by `ccl-compile' (for backward compatibility.
     * In the latter case, the execution overhead is bigger than in the former).
     * No I/O commands should appear in CCL-PROGRAM.
     *
     * REGISTERS is a vector of [R0 R1 ... R7] where RN is an initial value
     * for the Nth register.
     *
     * As side effect, each element of REGISTERS holds the value of
     * the corresponding register after the execution.
     *
     * See the documentation of `define-ccl-program' for a definition of CCL
     * programs.
     * </pre>
     */
    @ELispBuiltIn(name = "ccl-execute", minArgs = 2, maxArgs = 2)
    @GenerateNodeFactory
    public abstract static class FCclExecute extends ELispBuiltInBaseNode {
        @Specialization
        public static Void cclExecute(Object cclProg, Object reg) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * <pre>
     * Execute CCL-PROGRAM with initial STATUS on STRING.
     *
     * CCL-PROGRAM is a symbol registered by `register-ccl-program',
     * or a compiled code generated by `ccl-compile' (for backward compatibility,
     * in this case, the execution is slower).
     *
     * Read buffer is set to STRING, and write buffer is allocated automatically.
     *
     * STATUS is a vector of [R0 R1 ... R7 IC], where
     *  R0..R7 are initial values of corresponding registers,
     *  IC is the instruction counter specifying from where to start the program.
     * If R0..R7 are nil, they are initialized to 0.
     * If IC is nil, it is initialized to head of the CCL program.
     *
     * If optional 4th arg CONTINUE is non-nil, keep IC on read operation
     * when read buffer is exhausted, else, IC is always set to the end of
     * CCL-PROGRAM on exit.
     *
     * It returns the contents of write buffer as a string,
     *  and as side effect, STATUS is updated.
     * If the optional 5th arg UNIBYTE-P is non-nil, the returned string
     * is a unibyte string.  By default it is a multibyte string.
     *
     * See the documentation of `define-ccl-program' for the detail of CCL program.
     * usage: (ccl-execute-on-string CCL-PROGRAM STATUS STRING &amp;optional CONTINUE UNIBYTE-P)
     * </pre>
     */
    @ELispBuiltIn(name = "ccl-execute-on-string", minArgs = 3, maxArgs = 5)
    @GenerateNodeFactory
    public abstract static class FCclExecuteOnString extends ELispBuiltInBaseNode {
        @Specialization
        public static Void cclExecuteOnString(Object cclProgram, Object status, Object string, Object continue_, Object unibyteP) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * <pre>
     * Register CCL program CCL-PROG as NAME in `ccl-program-table'.
     * CCL-PROG should be a compiled CCL program (vector), or nil.
     * If it is nil, just reserve NAME as a CCL program name.
     * Return index number of the registered CCL program.
     * </pre>
     */
    @ELispBuiltIn(name = "register-ccl-program", minArgs = 2, maxArgs = 2)
    @GenerateNodeFactory
    public abstract static class FRegisterCclProgram extends ELispBuiltInBaseNode {
        @Specialization
        public long registerCclProgram(ELispSymbol name, Object cclProg) {
            BuiltInCcl ccl = getThis(this);
            long index = ccl.cclPrograms.size();
            ccl.cclProgramIndices.put(name, index);
            ccl.cclPrograms.add(new CclProgram(cclProg instanceof ELispVector v ? v : new ELispVector(List.of())));
            return index;
        }
    }

    /**
     * <pre>
     * Register SYMBOL as code conversion map MAP.
     * Return index number of the registered map.
     * </pre>
     */
    @ELispBuiltIn(name = "register-code-conversion-map", minArgs = 2, maxArgs = 2)
    @GenerateNodeFactory
    public abstract static class FRegisterCodeConversionMap extends ELispBuiltInBaseNode {
        @Specialization
        public static Void registerCodeConversionMap(Object symbol, Object map) {
            throw new UnsupportedOperationException();
        }
    }
}
