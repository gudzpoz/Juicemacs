package party.iroiro.juicemacs.elisp.forms;

import com.oracle.truffle.api.TruffleFile;
import com.oracle.truffle.api.dsl.GenerateNodeFactory;
import com.oracle.truffle.api.dsl.NodeFactory;
import com.oracle.truffle.api.dsl.Specialization;
import com.oracle.truffle.api.source.Source;
import org.eclipse.jdt.annotation.Nullable;
import party.iroiro.juicemacs.elisp.ELispLanguage;
import party.iroiro.juicemacs.elisp.nodes.ELispExpressionNode;
import party.iroiro.juicemacs.elisp.parser.ELispParser;
import party.iroiro.juicemacs.elisp.runtime.ELispContext;
import party.iroiro.juicemacs.elisp.runtime.ELispGlobals;
import party.iroiro.juicemacs.elisp.runtime.objects.*;

import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Path;
import java.util.HashSet;
import java.util.List;

import static party.iroiro.juicemacs.elisp.forms.BuiltInEval.evalSub;
import static party.iroiro.juicemacs.elisp.runtime.ELispContext.*;

/**
 * Built-in functions from {@code src/lread.c}
 */
public class BuiltInLRead extends ELispBuiltIns {
    @Override
    protected List<? extends NodeFactory<? extends ELispBuiltInBaseNode>> getNodeFactories() {
        return BuiltInLReadFactory.getFactories();
    }

    @ELispBuiltIn(name = "read-char", minArgs = 0, maxArgs = 3, doc = "Read a character event from the command input (keyboard or macro).\nIt is returned as a number.\nIf the event has modifiers, they are resolved and reflected in the\nreturned character code if possible (e.g. C-SPC yields 0 and C-a yields 97).\nIf some of the modifiers cannot be reflected in the character code, the\nreturned value will include those modifiers, and will not be a valid\ncharacter code: it will fail the `characterp' test.  Use `event-basic-type'\nto recover the character code with the modifiers removed.\n\nIf the user generates an event which is not a character (i.e. a mouse\nclick or function key event), `read-char' signals an error.  As an\nexception, switch-frame events are put off until non-character events\ncan be read.\nIf you want to read non-character events, or ignore them, call\n`read-event' or `read-char-exclusive' instead.\n\nIf the optional argument PROMPT is non-nil, display that as a prompt.\nIf PROMPT is nil or the string \\\"\\\", the key sequence/events that led\nto the current command is used as the prompt.\n\nIf the optional argument INHERIT-INPUT-METHOD is non-nil and some\ninput method is turned on in the current buffer, that input method\nis used for reading a character.\n\nIf the optional argument SECONDS is non-nil, it should be a number\nspecifying the maximum number of seconds to wait for input.  If no\ninput arrives in that time, return nil.  SECONDS may be a\nfloating-point value.\n\nIf `inhibit-interaction' is non-nil, this function will signal an\n`inhibited-interaction' error.")
    @GenerateNodeFactory
    public abstract static class FReadChar extends ELispBuiltInBaseNode {
        @Specialization
        public static Object readChar(Object a, Object b, Object c) {
            throw new UnsupportedOperationException();
        }
    }

    @ELispBuiltIn(name = "read-event", minArgs = 0, maxArgs = 3, doc = "Read an event object from the input stream.\n\nIf you want to read non-character events, consider calling `read-key'\ninstead.  `read-key' will decode events via `input-decode-map' that\n`read-event' will not.  On a terminal this includes function keys such\nas <F7> and <RIGHT>, or mouse events generated by `xterm-mouse-mode'.\n\nIf the optional argument PROMPT is non-nil, display that as a prompt.\nIf PROMPT is nil or the string \\\"\\\", the key sequence/events that led\nto the current command is used as the prompt.\n\nIf the optional argument INHERIT-INPUT-METHOD is non-nil and some\ninput method is turned on in the current buffer, that input method\nis used for reading a character.\n\nIf the optional argument SECONDS is non-nil, it should be a number\nspecifying the maximum number of seconds to wait for input.  If no\ninput arrives in that time, return nil.  SECONDS may be a\nfloating-point value.\n\nIf `inhibit-interaction' is non-nil, this function will signal an\n`inhibited-interaction' error.")
    @GenerateNodeFactory
    public abstract static class FReadEvent extends ELispBuiltInBaseNode {
        @Specialization
        public static Object readEvent(Object a, Object b, Object c) {
            throw new UnsupportedOperationException();
        }
    }

    @ELispBuiltIn(name = "read-char-exclusive", minArgs = 0, maxArgs = 3, doc = "Read a character event from the command input (keyboard or macro).\nIt is returned as a number.  Non-character events are ignored.\nIf the event has modifiers, they are resolved and reflected in the\nreturned character code if possible (e.g. C-SPC yields 0 and C-a yields 97).\nIf some of the modifiers cannot be reflected in the character code, the\nreturned value will include those modifiers, and will not be a valid\ncharacter code: it will fail the `characterp' test.  Use `event-basic-type'\nto recover the character code with the modifiers removed.\n\nIf the optional argument PROMPT is non-nil, display that as a prompt.\nIf PROMPT is nil or the string \\\"\\\", the key sequence/events that led\nto the current command is used as the prompt.\n\nIf the optional argument INHERIT-INPUT-METHOD is non-nil and some\ninput method is turned on in the current buffer, that input method\nis used for reading a character.\n\nIf the optional argument SECONDS is non-nil, it should be a number\nspecifying the maximum number of seconds to wait for input.  If no\ninput arrives in that time, return nil.  SECONDS may be a\nfloating-point value.\n\nIf `inhibit-interaction' is non-nil, this function will signal an\n`inhibited-interaction' error.")
    @GenerateNodeFactory
    public abstract static class FReadCharExclusive extends ELispBuiltInBaseNode {
        @Specialization
        public static Object readCharExclusive(Object a, Object b, Object c) {
            throw new UnsupportedOperationException();
        }
    }

    @ELispBuiltIn(name = "get-load-suffixes", minArgs = 0, maxArgs = 0, doc = "Return the suffixes that `load' should try if a suffix is \\\nrequired.\nThis uses the variables `load-suffixes' and `load-file-rep-suffixes'.")
    @GenerateNodeFactory
    public abstract static class FGetLoadSuffixes extends ELispBuiltInBaseNode {
        @Specialization
        public static Object getLoadSuffixes() {
            throw new UnsupportedOperationException();
        }
    }

    @ELispBuiltIn(name = "load", minArgs = 1, maxArgs = 5, doc = "Execute a file of Lisp code named FILE.\nFirst try FILE with `.elc' appended, then try with `.el', then try\nwith a system-dependent suffix of dynamic modules (see `load-suffixes'),\nthen try FILE unmodified (the exact suffixes in the exact order are\ndetermined by `load-suffixes').  Environment variable references in\nFILE are replaced with their values by calling `substitute-in-file-name'.\nThis function searches the directories in `load-path'.\n\nIf optional second arg NOERROR is non-nil,\nreport no error if FILE doesn't exist.\nPrint messages at start and end of loading unless\noptional third arg NOMESSAGE is non-nil (but `force-load-messages'\noverrides that).\nIf optional fourth arg NOSUFFIX is non-nil, don't try adding\nsuffixes to the specified name FILE.\nIf optional fifth arg MUST-SUFFIX is non-nil, insist on\nthe suffix `.elc' or `.el' or the module suffix; don't accept just\nFILE unless it ends in one of those suffixes or includes a directory name.\n\nIf NOSUFFIX is nil, then if a file could not be found, try looking for\na different representation of the file by adding non-empty suffixes to\nits name, before trying another file.  Emacs uses this feature to find\ncompressed versions of files when Auto Compression mode is enabled.\nIf NOSUFFIX is non-nil, disable this feature.\n\nThe suffixes that this function tries out, when NOSUFFIX is nil, are\ngiven by the return value of `get-load-suffixes' and the values listed\nin `load-file-rep-suffixes'.  If MUST-SUFFIX is non-nil, only the\nreturn value of `get-load-suffixes' is used, i.e. the file name is\nrequired to have a non-empty suffix.\n\nWhen searching suffixes, this function normally stops at the first\none that exists.  If the option `load-prefer-newer' is non-nil,\nhowever, it tries all suffixes, and uses whichever file is the newest.\n\nLoading a file records its definitions, and its `provide' and\n`require' calls, in an element of `load-history' whose\ncar is the file name loaded.  See `load-history'.\n\nWhile the file is in the process of being loaded, the variable\n`load-in-progress' is non-nil and the variable `load-file-name'\nis bound to the file's name.\n\nReturn t if the file exists and loads successfully.")
    @GenerateNodeFactory
    public abstract static class FLoad extends ELispBuiltInBaseNode {
        @Specialization
        public static boolean load(ELispString file, boolean noError, boolean noMessage,
                                   boolean noSuffix, boolean mustSuffix) {
            Object loadPath = ELispGlobals.loadPath;
            if (ELispSymbol.isNil(loadPath)) {
                return false;
            }
            String stem = file.toString();
            for (Object path : ((ELispCons) loadPath)) {
                Path directory = Path.of(((ELispString) path).toString());
                Path target = directory.resolve(stem + ".elc");
                if (!target.toFile().isFile()) {
                    target = directory.resolve(stem + ".el");
                }
                if (target.toFile().isFile()) {
                    try {
                        ELispParser parser = new ELispParser(Source.newBuilder(
                                "elisp",
                                new FileReader(target.toFile()),
                                target.toFile().getName()
                        ).build());
                        while (true) {
                            Object lisp = parser.nextLisp();
                            evalSub(lisp);
                        }
                    } catch (IOException e) {
                        return true;
                    }
                }
            }
            return false;
        }
    }

    @ELispBuiltIn(name = "locate-file-internal", minArgs = 2, maxArgs = 4, doc = "Search for FILENAME through PATH.\nReturns the file's name in absolute form, or nil if not found.\nIf SUFFIXES is non-nil, it should be a list of suffixes to append to\nfile name when searching.\nIf non-nil, PREDICATE is used instead of `file-readable-p'.\nPREDICATE can also be an integer to pass to the faccessat(2) function,\nin which case file-name-handlers are ignored.\nThis function will normally skip directories, so if you want it to find\ndirectories, make sure the PREDICATE function returns `dir-ok' for them.")
    @GenerateNodeFactory
    public abstract static class FLocateFileInternal extends ELispBuiltInBaseNode {
        @Specialization
        public static Object locateFileInternal(Object a, Object b, Object c, Object d) {
            throw new UnsupportedOperationException();
        }
    }

    @ELispBuiltIn(name = "eval-buffer", minArgs = 0, maxArgs = 5, doc = "Execute the accessible portion of current buffer as Lisp code.\nYou can use \\\\[narrow-to-region] to limit the part of buffer to be evaluated.\nWhen called from a Lisp program (i.e., not interactively), this\nfunction accepts up to five optional arguments:\nBUFFER is the buffer to evaluate (nil means use current buffer),\n or a name of a buffer (a string).\nPRINTFLAG controls printing of output by any output functions in the\n evaluated code, such as `print', `princ', and `prin1':\n  a value of nil means discard it; anything else is the stream to print to.\n  See Info node `(elisp)Output Streams' for details on streams.\nFILENAME specifies the file name to use for `load-history'.\nUNIBYTE, if non-nil, specifies `load-convert-to-unibyte' for this\n invocation.\nDO-ALLOW-PRINT, if non-nil, specifies that output functions in the\n evaluated code should work normally even if PRINTFLAG is nil, in\n which case the output is displayed in the echo area.\n\nThis function ignores the current value of the `lexical-binding'\nvariable.  Instead it will heed any\n  -*- lexical-binding: t -*-\nsettings in the buffer, and if there is no such setting, the buffer\nwill be evaluated without lexical binding.\n\nThis function preserves the position of point.")
    @GenerateNodeFactory
    public abstract static class FEvalBuffer extends ELispBuiltInBaseNode {
        @Specialization
        public static Object evalBuffer(Object a, Object b, Object c, Object d, Object e) {
            throw new UnsupportedOperationException();
        }
    }

    @ELispBuiltIn(name = "eval-region", minArgs = 2, maxArgs = 4, doc = "Execute the region as Lisp code.\nWhen called from programs, expects two arguments,\ngiving starting and ending indices in the current buffer\nof the text to be executed.\nPrograms can pass third argument PRINTFLAG which controls output:\n a value of nil means discard it; anything else is stream for printing it.\n See Info node `(elisp)Output Streams' for details on streams.\nAlso the fourth argument READ-FUNCTION, if non-nil, is used\ninstead of `read' to read each expression.  It gets one argument\nwhich is the input stream for reading characters.\n\nThis function does not move point.")
    @GenerateNodeFactory
    public abstract static class FEvalRegion extends ELispBuiltInBaseNode {
        @Specialization
        public static Object evalRegion(Object a, Object b, Object c, Object d) {
            throw new UnsupportedOperationException();
        }
    }

    @ELispBuiltIn(name = "read", minArgs = 0, maxArgs = 1, doc = "Read one Lisp expression as text from STREAM, return as Lisp object.\nIf STREAM is nil, use the value of `standard-input' (which see).\nSTREAM or the value of `standard-input' may be:\n a buffer (read from point and advance it)\n a marker (read from where it points and advance it)\n a function (call it with no arguments for each character,\n     call it with a char as argument to push a char back)\n a string (takes text from string, starting at the beginning)\n t (read text line using minibuffer and use it, or read from\n    standard input in batch mode).")
    @GenerateNodeFactory
    public abstract static class FRead extends ELispBuiltInBaseNode {
        @Specialization
        public static Object read(Object a) {
            if (ELispSymbol.isNil(a)) {
                // TODO: Vstandard_input
                throw new UnsupportedOperationException();
            }
            if (ELispSymbol.isT(a)) {
                a = READ_CHAR;
            }
            if (a == READ_CHAR) {
                throw new UnsupportedOperationException();
            }
            return readInternalStart(a, NIL, NIL, false);
        }
    }

    public static Object readInternalStart(
            Object stream, Object start, Object end, boolean locateSymbols
    ) {
        // TODO: Handle stream instanceof ELispBuffer, ELispCons
        ELispString s = (ELispString) stream;
        Source source = Source.newBuilder(ELispLanguage.ID, s.toString(), null).build();
        try {
            return ELispParser.read(source);
        } catch (IOException e) {
            throw new IllegalArgumentException(e);
        }
    }

    @ELispBuiltIn(name = "read-positioning-symbols", minArgs = 0, maxArgs = 1, doc = "Read one Lisp expression as text from STREAM, return as Lisp object.\nConvert each occurrence of a symbol into a \"symbol with pos\" object.\n\nIf STREAM is nil, use the value of `standard-input' (which see).\nSTREAM or the value of `standard-input' may be:\n a buffer (read from point and advance it)\n a marker (read from where it points and advance it)\n a function (call it with no arguments for each character,\n     call it with a char as argument to push a char back)\n a string (takes text from string, starting at the beginning)\n t (read text line using minibuffer and use it, or read from\n    standard input in batch mode).")
    @GenerateNodeFactory
    public abstract static class FReadPositioningSymbols extends ELispBuiltInBaseNode {
        @Specialization
        public static Object readPositioningSymbols(Object a) {
            throw new UnsupportedOperationException();
        }
    }

    @ELispBuiltIn(name = "read-from-string", minArgs = 1, maxArgs = 3, doc = "Read one Lisp expression which is represented as text by STRING.\nReturns a cons: (OBJECT-READ . FINAL-STRING-INDEX).\nFINAL-STRING-INDEX is an integer giving the position of the next\nremaining character in STRING.  START and END optionally delimit\na substring of STRING from which to read;  they default to 0 and\n\\(length STRING) respectively.  Negative values are counted from\nthe end of STRING.")
    @GenerateNodeFactory
    public abstract static class FReadFromString extends ELispBuiltInBaseNode {
        @Specialization
        public static Object readFromString(Object a, Object b, Object c) {
            throw new UnsupportedOperationException();
        }
    }

    @ELispBuiltIn(name = "lread--substitute-object-in-subtree", minArgs = 3, maxArgs = 3, doc = "In OBJECT, replace every occurrence of PLACEHOLDER with OBJECT.\nCOMPLETED is a hash table of objects that might be circular, or is t\nif any object might be circular.")
    @GenerateNodeFactory
    public abstract static class FLreadSubstituteObjectInSubtree extends ELispBuiltInBaseNode {
        @Specialization
        public static Object lreadSubstituteObjectInSubtree(Object obj, Object placeholder, Object recursive) {
            new SubstituteObjectRecurse(
                    obj,
                    placeholder,
                    recursive instanceof ELispHashtable t ? t : null,
                    recursive instanceof ELispHashtable ? null : new HashSet<>()
            ).substitute(obj);
            return NIL; // return Qnil;
        }
    }

    /**
     * See {@code substitute_object_recurse} in {@code src/lread.c}
     */
    public record SubstituteObjectRecurse(
            Object object,
            Object placeholder,
            @Nullable ELispHashtable recursive,
            @Nullable HashSet<Object> seen
    ) {
        public Object substitute(Object tree) {
            if (tree == placeholder) {
                return object;
            }
            return switch (tree) {
                case Long _, Double _, ELispBigNum _, ELispSymbol _ -> tree;
                case ELispString s when s.intervals() == 0 -> tree;
                case ELispBoolVector _ -> tree;
                default -> {
                    if (recursive == null) {
                        if (seen != null && seen.contains(tree)) {
                            yield tree;
                        }
                    } else if (recursive.containsKey(tree)) {
                        yield tree;
                    }
                    yield switch (tree) {
                        case ELispCons cons -> {
                            cons.setCar(substitute(cons.car()));
                            cons.setCdr(substitute(cons.cdr()));
                            yield cons;
                        }
                        case ELispString s -> {
                            s.forProperties(this::substitute);
                            yield s;
                        }
                        case ELispVectorLike<?> vec -> {
                            // TODO: CHAR_TABLE_P, SUB_CHAR_TABLE_P, CLOSUREP, HASH_TABLE_P, RECORD P
                            for (int i = 0; i < vec.size(); i++) {
                                vec.setUntyped(i, substitute(vec.get(i)));
                            }
                            yield this;
                        }
                        default -> tree;
                    };
                }
            };
        }
    }

    @ELispBuiltIn(name = "intern", minArgs = 1, maxArgs = 2, doc = "Return the canonical symbol whose name is STRING.\nIf there is none, one is created by this function and returned.\nA second optional argument specifies the obarray to use;\nit defaults to the value of `obarray'.")
    @GenerateNodeFactory
    public abstract static class FIntern extends ELispBuiltInBaseNode {
        @Specialization
        public static Object intern(Object a, Object b) {
            throw new UnsupportedOperationException();
        }
    }

    @ELispBuiltIn(name = "intern-soft", minArgs = 1, maxArgs = 2, doc = "Return the canonical symbol named NAME, or nil if none exists.\nNAME may be a string or a symbol.  If it is a symbol, that exact\nsymbol is searched for.\nA second optional argument specifies the obarray to use;\nit defaults to the value of `obarray'.")
    @GenerateNodeFactory
    public abstract static class FInternSoft extends ELispBuiltInBaseNode {
        @Specialization
        public static Object internSoft(Object a, Object b) {
            throw new UnsupportedOperationException();
        }
    }

    @ELispBuiltIn(name = "unintern", minArgs = 1, maxArgs = 2, doc = "Delete the symbol named NAME, if any, from OBARRAY.\nThe value is t if a symbol was found and deleted, nil otherwise.\nNAME may be a string or a symbol.  If it is a symbol, that symbol\nis deleted, if it belongs to OBARRAY--no other symbol is deleted.\nOBARRAY, if nil, defaults to the value of the variable `obarray'.\nusage: (unintern NAME OBARRAY)")
    @GenerateNodeFactory
    public abstract static class FUnintern extends ELispBuiltInBaseNode {
        @Specialization
        public static Object unintern(Object a, Object b) {
            throw new UnsupportedOperationException();
        }
    }

    @ELispBuiltIn(name = "obarray-make", minArgs = 0, maxArgs = 1, doc = "Return a new obarray of size SIZE.\nThe obarray will grow to accommodate any number of symbols; the size, if\ngiven, is only a hint for the expected number.")
    @GenerateNodeFactory
    public abstract static class FObarrayMake extends ELispBuiltInBaseNode {
        @Specialization
        public static Object obarrayMake(Object a) {
            throw new UnsupportedOperationException();
        }
    }

    @ELispBuiltIn(name = "obarrayp", minArgs = 1, maxArgs = 1, doc = "Return t iff OBJECT is an obarray.")
    @GenerateNodeFactory
    public abstract static class FObarrayp extends ELispBuiltInBaseNode {
        @Specialization
        public static Object obarrayp(Object a) {
            throw new UnsupportedOperationException();
        }
    }

    @ELispBuiltIn(name = "obarray-clear", minArgs = 1, maxArgs = 1, doc = "Remove all symbols from OBARRAY.")
    @GenerateNodeFactory
    public abstract static class FObarrayClear extends ELispBuiltInBaseNode {
        @Specialization
        public static Object obarrayClear(Object a) {
            throw new UnsupportedOperationException();
        }
    }

    @ELispBuiltIn(name = "mapatoms", minArgs = 1, maxArgs = 2, doc = "Call FUNCTION on every symbol in OBARRAY.\nOBARRAY defaults to the value of `obarray'.")
    @GenerateNodeFactory
    public abstract static class FMapatoms extends ELispBuiltInBaseNode {
        @Specialization
        public static Object mapatoms(Object a, Object b) {
            throw new UnsupportedOperationException();
        }
    }

    @ELispBuiltIn(name = "internal--obarray-buckets", minArgs = 1, maxArgs = 1, doc = "Symbols in each bucket of OBARRAY.  Internal use only.")
    @GenerateNodeFactory
    public abstract static class FInternalObarrayBuckets extends ELispBuiltInBaseNode {
        @Specialization
        public static Object internalObarrayBuckets(Object a) {
            throw new UnsupportedOperationException();
        }
    }
}
